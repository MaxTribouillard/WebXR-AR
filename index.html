<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR AR Test</title>
    <script src="https://cdn.jsdelivr.net/npm/babylonjs@8.38.0/babylon.min.js"></script>
   <script src="https://cdn.jsdelivr.net/npm/babylonjs-loaders@8.38.0/babylonjs.loaders.min.js"></script>
    <script src="zappar/zappar-babylon.js"></script>
</head>
<body>
    <button id="startAR" style="position: absolute; z-index: 10; top: 20px; left: 20px;">
    Démarrer AR
</button>
    <canvas id="renderCanvas" style="width:100%; height:100vh;"></canvas>

    <script>

        const canvas = document.getElementById('renderCanvas');

        const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
        const scene = new BABYLON.Scene(engine);
        const light = new BABYLON.HemisphericLight('light1', new BABYLON.Vector3(0, 1, 0), scene);


        const camera = new ZapparBabylon.Camera('camera', scene);
        // camera.setCameraPoseMode(ZapparBabylon.CameraPoseMode.Attitude);

        const instantWorldTracker = new ZapparBabylon.InstantWorldTracker();
        instantWorldTracker.setAnchorPoseFromCameraOffset(0, 0, -5);
        const trackerTransformNode = new ZapparBabylon.InstantWorldAnchorTransformNode('tracker', camera, instantWorldTracker, scene);

        const assetsManager = new BABYLON.AssetsManager(scene);

        // Charger modèle GLB
        const meshTask = assetsManager.addMeshTask("loadGLB", "", "model/", "model.glb");

        meshTask.onSuccess = function(task) {
            task.loadedMeshes.forEach(m => m.parent = trackerTransformNode);
        };

        meshTask.onError = function(task, message) {
            console.error("Erreur de GLB:", message);
        };

        assetsManager.load();

        // BOUTON START AR
        document.getElementById("startAR").onclick = async () => {
            const granted = await ZapparBabylon.permissionRequestUI();
            if (!granted) {
                ZapparBabylon.permissionDeniedUI();
                return;
            }

            // Démarrage caméra
            camera.start();

            // Lancer le rendu Babylon après le démarrage caméra
            engine.runRenderLoop(() => {
                camera.updateFrame();
                instantWorldTracker.setAnchorPoseFromCameraOffset(0,0,-5);
                scene.render();
            });

            // Cacher le bouton
            document.getElementById("startAR").style.display = "none";

            let selectedMesh = null;
            let touchStartPosition = null;

            // Activer les pickers sur le canvas
            canvas.addEventListener('pointerdown', (event) => {
                const pickResult = scene.pick(scene.pointerX, scene.pointerY);
                if (pickResult.hit && pickResult.pickedMesh) {
                    selectedMesh = pickResult.pickedMesh;
                    touchStartPosition = { x: event.clientX, y: event.clientY };
                }
            });

            canvas.addEventListener('pointermove', (event) => {
                if (!selectedMesh || !touchStartPosition) return;

                // Calcul du déplacement en pixels
                const dx = event.clientX - touchStartPosition.x;
                const dz = event.clientY - touchStartPosition.y;

                // Conversion simple en offset dans le monde AR
                selectedMesh.position.x += dx * 0.001; // ajuster facteur selon ton besoin
                selectedMesh.position.z += dz * 0.001;

                touchStartPosition = { x: event.clientX, y: event.clientY };
            });

            canvas.addEventListener('pointerup', () => {
                selectedMesh = null;
                touchStartPosition = null;
            });
        };
</script>

    </script>
</body>
</html>